import { auth } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { decryptToken } from '@/lib/shopify-oauth'
import { fetchProductDescription } from '@/lib/shopify-product-details'
import { generateKeywords } from '@/lib/openai'

// Force dynamic rendering (required for auth and database queries)
export const dynamic = 'force-dynamic'

/**
 * POST /api/keywords/seed
 * Generates and seeds keywords for all product and collection pages
 */
export async function POST() {
  try {
    const { userId } = await auth()

    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user and their site
    const user = await prisma.user.findUnique({
      where: { clerkId: userId },
      include: { sites: true },
    })

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    const site = user.sites[0]

    if (!site) {
      return NextResponse.json({ error: 'No Shopify store connected' }, { status: 400 })
    }

    if (!site.shopifyAccessToken) {
      return NextResponse.json(
        { error: 'Shopify access token not found' },
        { status: 400 }
      )
    }

    // Decrypt access token
    const accessToken = decryptToken(site.shopifyAccessToken)
    const shop = site.domain

    console.log(`[Keywords Seed] Starting keyword generation for shop: ${shop}`)

    // Fetch all product and collection pages
    const pages = await prisma.page.findMany({
      where: {
        siteId: site.id,
        type: {
          in: ['PRODUCT', 'COLLECTION'],
        },
      },
    })

    console.log(`[Keywords Seed] Found ${pages.length} pages to process`)

    let totalKeywordsCreated = 0
    let totalKeywordsSkipped = 0
    const pageDetails: Array<{
      pageTitle: string
      pageType: string
      keywordsGenerated: number
      keywordsCreated: number
      keywordsSkipped: number
      error?: string
    }> = []

    // Process pages in batches to avoid rate limits
    for (const page of pages) {
      try {
        // Get product description if it's a product
        let description: string | undefined
        if (page.type === 'PRODUCT') {
          description = (await fetchProductDescription(shop, accessToken, page.shopifyId)) || undefined
        }

        // Generate keywords using LLM
        console.log(`[Keywords Seed] Generating keywords for ${page.type}: "${page.title}"${description ? ` (with description)` : ' (title only)'}`)
        const keywordPhrases = await generateKeywords(page.title, description)

        console.log(`[Keywords Seed] Generated ${keywordPhrases.length} keywords:`, keywordPhrases)

        if (keywordPhrases.length === 0) {
          console.warn(`[Keywords Seed] No keywords generated for ${page.type}: ${page.title}`)
          pageDetails.push({
            pageTitle: page.title,
            pageType: page.type,
            keywordsGenerated: 0,
            keywordsCreated: 0,
            keywordsSkipped: 0,
            error: 'No keywords generated by LLM',
          })
          continue
        }

        // Store keywords (idempotent - skip if already exists)
        let createdForThisPage = 0
        let skippedForThisPage = 0

        for (const keywordPhrase of keywordPhrases) {
          const trimmed = keywordPhrase.trim()
          if (!trimmed) {
            console.log(`[Keywords Seed] Skipping empty keyword`)
            continue
          }

          const source = `${page.type.toLowerCase()}:${page.shopifyId}`

          try {
            await prisma.keyword.create({
              data: {
                siteId: site.id,
                keyword: trimmed,
                source,
              },
            })
            totalKeywordsCreated++
            createdForThisPage++
            console.log(`[Keywords Seed] ✓ Created keyword: "${trimmed}" (source: ${source})`)
          } catch (error: any) {
            // Skip if keyword already exists (unique constraint)
            if (error.code === 'P2002') {
              skippedForThisPage++
              console.log(`[Keywords Seed] ⊘ Keyword already exists: "${trimmed}"`)
              continue
            }
            console.error(`[Keywords Seed] Error creating keyword "${trimmed}":`, error)
            throw error
          }
        }

        console.log(`[Keywords Seed] Page "${page.title}": Created ${createdForThisPage}, Skipped ${skippedForThisPage}`)
        totalKeywordsSkipped += skippedForThisPage

        pageDetails.push({
          pageTitle: page.title,
          pageType: page.type,
          keywordsGenerated: keywordPhrases.length,
          keywordsCreated: createdForThisPage,
          keywordsSkipped: skippedForThisPage,
        })

        // Small delay to avoid rate limits
        await new Promise((resolve) => setTimeout(resolve, 100))
      } catch (error) {
        console.error(`[Keywords Seed] Error processing page ${page.id}:`, error)
        pageDetails.push({
          pageTitle: page.title,
          pageType: page.type,
          keywordsGenerated: 0,
          keywordsCreated: 0,
          keywordsSkipped: 0,
          error: error instanceof Error ? error.message : 'Unknown error',
        })
        // Continue with next page
        continue
      }
    }

    console.log(`[Keywords Seed] Complete. Created ${totalKeywordsCreated} keywords, Skipped ${totalKeywordsSkipped}`)

    // Check if keywords already exist in database
    const existingKeywordCount = await prisma.keyword.count({
      where: { siteId: site.id },
    })

    return NextResponse.json({
      success: true,
      message: 'Keywords seeded successfully',
      pagesProcessed: pages.length,
      keywordsCreated: totalKeywordsCreated,
      keywordsSkipped: totalKeywordsSkipped,
      totalKeywordsInDatabase: existingKeywordCount,
      pageDetails, // Detailed breakdown per page
    })
  } catch (error) {
    console.error('[Keywords Seed] Error:', error)
    return NextResponse.json(
      {
        error: 'Failed to seed keywords',
        message: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    )
  }
}

