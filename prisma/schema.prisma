// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum SiteType {
  SHOPIFY
}

enum ContentStatus {
  DRAFT
  PUBLISHED
  SCHEDULED
}

enum AutopilotRunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum PageType {
  PRODUCT
  COLLECTION
  ARTICLE
}

// ============================================================================
// MODELS
// ============================================================================

// User: Links application users to Clerk authentication
// Why: Core identity table that connects Clerk auth to application data
// - clerkId: Unique identifier from Clerk (used for auth lookups)
// - email: User's email (for display and communication)
// - Sites: One user can own multiple Shopify stores
model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sites Site[]

  @@map("users")
}

// Site: Represents a Shopify store connected to the platform
// Why: Central entity for organizing all SEO work per store
// - domain: Store's primary domain (e.g., "example.myshopify.com")
// - shopifyStoreUrl: Full Shopify store URL
// - shopifyAccessToken: Encrypted token for Shopify API access
// - All SEO entities (Keywords, Content, Prompts, Runs) belong to a Site
model Site {
  id                String   @id @default(cuid())
  userId            String
  type              SiteType @default(SHOPIFY)
  domain            String
  shopifyStoreUrl   String
  shopifyAccessToken String? // Encrypted token for API access
  name              String?
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  keywords      Keyword[]
  content       Content[]
  prompts       Prompt[]
  autopilotRuns AutopilotRun[]
  pages         Page[]

  @@unique([userId, domain])
  @@map("sites")
}

// Keyword: SEO keywords tracked for a site
// Why: Core SEO entity - tracks which keywords we're targeting per site
// - keyword: The actual search term (e.g., "organic coffee beans")
// - targetUrl: Which page/blog post should rank for this keyword
// - currentRanking: Current Google ranking position (nullable if not ranked)
// - source: Where the keyword came from (e.g., "product:123", "collection:456", "seed")
// - Notes: For tracking research, competition, etc.
model Keyword {
  id            String   @id @default(cuid())
  siteId        String
  keyword       String
  targetUrl     String?  // URL this keyword should rank for
  currentRanking Int?    // Current Google ranking (1-100, null if not ranked)
  source        String?  // Source of the keyword (e.g., "product:123", "collection:456", "seed")
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  site Site @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@unique([siteId, keyword])
  @@map("keywords")
}

// Content: Shopify blog posts managed by the platform
// Why: Tracks blog posts created/updated for SEO purposes
// - shopifyArticleId: ID from Shopify's API (for syncing)
// - title: Blog post title
// - url: Full URL to the published post
// - status: Whether it's draft, published, or scheduled
// - publishedAt: When it was/will be published
// - Links to the Site that owns it
model Content {
  id              String        @id @default(cuid())
  siteId          String
  shopifyArticleId String?      @unique // Shopify API article ID
  title           String
  url             String?
  status          ContentStatus @default(DRAFT)
  publishedAt     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  site Site @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@map("content")
}

// Prompt: Tracks AI prompts used for content generation
// Why: Audit trail and optimization - see what prompts work best
// - name: Human-readable name for the prompt (e.g., "Blog Intro Generator")
// - promptText: The actual prompt template used
// - version: For tracking prompt iterations (start at 1)
// - Allows A/B testing and improving prompts over time
model Prompt {
  id          String   @id @default(cuid())
  siteId      String
  name        String
  promptText  String   // The actual prompt template
  version     Int      @default(1)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  site Site @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@unique([siteId, name, version])
  @@map("prompts")
}

// AutopilotRun: Logs weekly automated job executions
// Why: Track when autopilot jobs run, their status, and results
// - scheduledFor: When the job was scheduled to run
// - startedAt: Actual start time
// - completedAt: When it finished (null if still running/failed)
// - status: Current state (PENDING, RUNNING, COMPLETED, FAILED)
// - errorMessage: If failed, what went wrong
// - resultSummary: JSON field for storing job results/metrics
model AutopilotRun {
  id            String              @id @default(cuid())
  siteId         String
  scheduledFor   DateTime
  startedAt      DateTime?
  completedAt    DateTime?
  status         AutopilotRunStatus @default(PENDING)
  errorMessage   String?
  resultSummary  Json?              // JSON object for flexible result storage
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  // Relations
  site Site @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@index([siteId, scheduledFor])
  @@map("autopilot_runs")
}

// Page: Unified storage for Shopify products, collections, and blog articles
// Why: Baseline snapshot of all store pages for SEO analysis and tracking
// - shopify_id: Shopify's ID for the resource (product/collection/article ID)
// - type: Type of page (PRODUCT, COLLECTION, ARTICLE)
// - title: Display title
// - url: Full URL to the page (constructed from handle)
// - last_updated: When the resource was last updated in Shopify
// - tracking_enabled: Whether SEO tracking is enabled for this page
model Page {
  id             String   @id @default(cuid())
  siteId         String
  shopifyId      String   // Shopify resource ID
  type           PageType
  title          String
  url            String
  lastUpdated    DateTime
  trackingEnabled Boolean  @default(false) // Whether SEO tracking is enabled
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  site            Site             @relation(fields: [siteId], references: [id], onDelete: Cascade)
  contentVersions ContentVersion[]

  @@unique([siteId, shopifyId, type])
  @@index([siteId, type])
  @@map("pages")
}

// ContentVersion: Stores generated content versions for pages
// Why: Track content iterations and versions for SEO optimization
// - page_id: Which page this content is for
// - version: Version number (starts at 1, increments for each new version)
// - content: The generated content (HTML or markdown)
// - reason: Why this version was created (e.g., "initial_creation", "seo_optimization", "a_b_test")
// - publishedAt: When this version was published to Shopify (null if not published)
// - Allows tracking content evolution and A/B testing
model ContentVersion {
  id         String    @id @default(cuid())
  pageId     String
  version    Int       // Version number (1, 2, 3, etc.)
  content    String    // Generated content (HTML or markdown)
  reason     String    // Reason for this version (e.g., "initial_creation")
  publishedAt DateTime? // When this version was published to Shopify
  createdAt  DateTime  @default(now())

  // Relations
  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@unique([pageId, version])
  @@index([pageId])
  @@map("content_versions")
}
